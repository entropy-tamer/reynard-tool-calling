/**
 * @file Execution utilities for codemode environment.
 *
 * This module contains utility functions for setting up and managing the codemode
 * execution environment, including environment setup, module loading, and code execution.
 *
 * @author Generated by Reynard AI Tool-Calling System
 */

import { createRequire } from "module";
// Native TypeScript tools are used for CodeMode execution

/**
 * Sets up environment variables to prevent git hooks during codemode execution.
 *
 * @example
 * ```typescript
 * setupCodemodeEnvironment();
 * // Sets SKIP_GIT_HOOKS, NODE_ENV, and CODEMODE_EXECUTION environment variables
 * ```
 */
export function setupCodemodeEnvironment(): void {
  process.env["SKIP_GIT_HOOKS"] = "true";
  process.env["NODE_ENV"] = "codemode";
  process.env["CODEMODE_EXECUTION"] = "true";
}

/**
 * Builds a tools facade from available native TypeScript tools.
 *
 * @returns Record of tool names to async functions organized by category
 * @example
 * ```typescript
 * const facade = await buildToolsFacade();
 * // Returns { agent: { ... }, development: { ... }, ... }
 * ```
 */
export async function buildToolsFacade() {
  const { buildToolsFacade } = await import("../tools");
  return buildToolsFacade();
}

/**
 * Loads Playwright packages with graceful fallbacks.
 *
 * @returns Object containing available Playwright packages
 * @example
 * ```typescript
 * const packages = await loadPlaywrightPackages();
 * // Returns { browser: playwrightWrapper, automation: browserAutomationClient, testRunner: TestRunner }
 * ```
 */
export async function loadPlaywrightPackages(): Promise<any> {
  const playwrightPackages: any = {};

  try {
    const { playwrightWrapper } = await import("./playwright/clients/playwright-wrapper.js");
    playwrightPackages.browser = playwrightWrapper;
  } catch (e: any) {
    console.warn("⚠️ Playwright wrapper not available:", e.message);
  }

  try {
    const { browserAutomationClient } = await import("./playwright/clients/browser-automation-client.js");
    playwrightPackages.automation = browserAutomationClient;
  } catch (e: any) {
    console.warn("⚠️ Browser automation client not available:", e.message);
  }

  try {
    const { TestRunner } = await import("./playwright/testing/test-runner.js");
    playwrightPackages.testRunner = new TestRunner();
  } catch (e: any) {
    console.warn("⚠️ E2E test runner not available:", e.message);
  }

  return playwrightPackages;
}

/**
 * Creates Node.js modules for the execution context.
 *
 * @returns Object containing required Node.js modules
 * @example
 * ```typescript
 * const modules = createNodeModules();
 * // Returns { fs: require('fs'), path: require('path'), os: require('os'), ... }
 * ```
 */
export function createNodeModules(): any {
  const require = createRequire(import.meta.url);
  return {
    child_process: require("child_process"),
    fs: require("fs"),
    path: require("path"),
    os: require("os"),
    util: require("util"),
    crypto: require("crypto"),
    url: require("url"),
    querystring: require("querystring"),
    http: require("http"),
    https: require("https"),
    stream: require("stream"),
    events: require("events"),
    buffer: require("buffer"),
    process: require("process"),
  };
}

/**
 * Executes user code in a controlled environment.
 *
 * @param code - The code to execute
 * @param context - Execution context with available modules and tools
 * @returns Execution result with success status and data
 * @example
 * ```typescript
 * const result = await executeUserCode('console.log("Hello");', context);
 * // Returns { success: true, data: undefined, metrics: { duration: 5 }, error: null }
 * ```
 */
export async function executeUserCode(code: string, context: any): Promise<any> {
  const startTime = Date.now();
  try {
    const modules = createNodeModules();
    const func = new Function(
      "tools",
      "algorithms",
      "playwright",
      "devToolsPackages",
      "codeQuality",
      "projectArchitecture",
      "dependencyGraph",
      "devServerManagement",
      "adrSystem",
      "diagramGenerator",
      "fileProcessing",
      "publicPackageManager",
      "queueWatcher",
      "apiClient",
      "console",
      "modules",
      "shouldSkipGitHooks",
      "proxyUrl",
      `return (async () => { 
        const require = (id) => {
          if (modules[id]) return modules[id];
          throw new Error(\`Module '\${id}' not available in codemode execution context\`);
        };
        const skipGitHooks = shouldSkipGitHooks();
        ${code} 
      })()`
    );

    const result = await func(
      context.tools,
      context.algorithms,
      context.playwrightPackages,
      context.devToolsPackages,
      context.devToolsPackages.codeQuality,
      context.devToolsPackages.projectArchitecture,
      context.devToolsPackages.dependencyGraph,
      context.devToolsPackages.devServerManagement,
      context.devToolsPackages.adrSystem,
      context.devToolsPackages.diagramGenerator,
      context.devToolsPackages.fileProcessing,
      context.devToolsPackages.publicPackageManager,
      context.devToolsPackages.queueWatcher,
      context.devToolsPackages.apiClient,
      console,
      modules,
      shouldSkipGitHooks,
      context.proxyUrl || null
    );

    const executionTime = Date.now() - startTime;
    return {
      success: true,
      data: result,
      returned: result,
      logs: [],
      metrics: { duration: executionTime, memoryUsedMB: 0, cpuPercent: 0 },
      error: null,
    };
  } catch (error) {
    const executionTime = Date.now() - startTime;
    return {
      success: false,
      data: null,
      returned: null,
      logs: [],
      metrics: { duration: executionTime, memoryUsedMB: 0, cpuPercent: 0 },
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Helper function to check if git hooks should be skipped during codemode execution.
 *
 * @returns {boolean} True if git hooks should be skipped, false otherwise
 * @example
 * ```typescript
 * if (shouldSkipGitHooks()) {
 *   console.log('Git hooks are disabled for codemode execution');
 * }
 * ```
 */
export function shouldSkipGitHooks(): boolean {
  return (
    process.env["SKIP_GIT_HOOKS"] === "true" ||
    process.env["CODEMODE_EXECUTION"] === "true" ||
    process.env["NODE_ENV"] === "codemode"
  );
}
