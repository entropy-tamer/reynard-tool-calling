/**
 * @file Code generation utilities for MCP (Model Context Protocol) tools.
 *
 * This module provides functionality to generate TypeScript interfaces and typed facades
 * for MCP tools based on their schema definitions. It creates type-safe wrappers that
 * call the underlying tools/call functionality.
 *
 * @author Generated by Reynard AI Tool-Calling System
 */

import { writeFileSync } from "fs";
import { resolve } from "path";
import { McpClient, McpTool } from "./mcp-client";

/**
 * Generates TypeScript type definitions for MCP tools and writes them to a file.
 *
 * @param projectRoot - The root directory of the project
 * @returns Promise that resolves when the types file has been written
 * @example
 * ```typescript
 * await generateTypes('/path/to/project');
 * // Generates mcp-types.ts with TypeScript interfaces for all available MCP tools
 * ```
 */
export async function generateTypes(projectRoot: string): Promise<void> {
  const client = new McpClient(projectRoot);
  await client.initialize();
  const tools = await client.toolsList();
  const out = resolve(projectRoot, "packages/ai/tool-calling/src/codemode/mcp-types.ts");
  const text = renderTypes(tools);
  writeFileSync(out, text, "utf8");
}

/**
 * Builds a typed facade for MCP tools that provides a clean API for tool calls.
 *
 * @param projectRoot - The root directory of the project
 * @returns Promise that resolves to the generated facade code as a string
 * @example
 * ```typescript
 * const facadeCode = await buildFacade('/path/to/project');
 * // Returns TypeScript code for a typed facade that wraps MCP tool calls
 * ```
 */
export async function buildFacade(projectRoot: string): Promise<string> {
  const client = new McpClient(projectRoot);
  await client.initialize();
  const tools = await client.toolsList();
  return renderFacade(tools);
}

/**
 * Renders a TypeScript facade that provides typed methods for calling MCP tools.
 *
 * @param tools - Array of MCP tools to generate facade methods for
 * @returns Generated TypeScript code for the facade
 * @example
 * ```typescript
 * const facadeCode = renderFacade([
 *   { name: 'search_files', description: 'Search for files' },
 *   { name: 'read_file', description: 'Read file contents' }
 * ]);
 * // Returns TypeScript code with typed methods for each tool
 * ```
 */
function renderFacade(tools: McpTool[]): string {
  const header = `/* AUTO-GENERATED: Do not edit by hand. */
import { McpClient } from "./mcp-client";

export function createMcpFacade(client: McpClient) {
  return {
`;

  const methods = tools
    .map(tool => {
      return `    ${tool.name}: async (input: Record<string, unknown> = {}) => {
      return await client.toolsCall("${tool.name}", input);
    }`;
    })
    .join(",\n");

  const footer = `
  };
}
`;

  return header + methods + footer;
}

/**
 * Renders TypeScript type definitions for MCP tools.
 *
 * @param tools - Array of MCP tools to generate types for
 * @returns Generated TypeScript code with interfaces and type definitions
 * @example
 * ```typescript
 * const typeCode = renderTypes([
 *   { name: 'search_files', description: 'Search for files' },
 *   { name: 'read_file', description: 'Read file contents' }
 * ]);
 * // Returns TypeScript interfaces like SearchFilesInput, ReadFileInput, etc.
 * ```
 */
function renderTypes(tools: McpTool[]): string {
  const header = `/* AUTO-GENERATED: Do not edit by hand. */\n\nexport type JsonValue = null | boolean | number | string | JsonValue[] | { [k: string]: JsonValue };\n\n`;
  const ifaceDecls: string[] = [];
  const callSigs: string[] = [];

  for (const t of tools) {
    const typeName = toTypeName(t.name) + "Input";
    ifaceDecls.push(`/** ${escapeDoc(t.description ?? "")} */\nexport interface ${typeName} { [k: string]: any }\n`);
    callSigs.push(`  ${t.name}(input: ${typeName}): Promise<any>;`);
  }

  const ns = `export interface McpTypesNamespace {\n${callSigs.join("\n")}\n}\n`;
  return header + ifaceDecls.join("\n") + "\n" + ns;
}

/**
 * Converts a tool name to a valid TypeScript type name using PascalCase.
 *
 * @param name - The tool name to convert
 * @returns PascalCase type name suitable for TypeScript interfaces
 * @example
 * ```typescript
 * toTypeName('search_files'); // Returns 'SearchFiles'
 * toTypeName('read-file'); // Returns 'ReadFile'
 * toTypeName('mcp_client'); // Returns 'McpClient'
 * ```
 */
function toTypeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9]+(.)/g, (_m, g1) => String(g1).toUpperCase())
    .replace(/^[a-z]/, c => c.toUpperCase());
}

/**
 * Escapes special characters in documentation strings for JSDoc comments.
 *
 * @param s - The string to escape
 * @returns Escaped string safe for use in JSDoc comments
 * @example
 * ```typescript
 * escapeDoc('This *is* a test'); // Returns 'This *is* a test'
 * escapeDoc('Function with **bold** text'); // Returns 'Function with **bold** text'
 * ```
 */
function escapeDoc(s: string): string {
  return s.replace(/\*/g, "*");
}
