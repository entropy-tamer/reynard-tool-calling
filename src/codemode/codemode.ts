/**
 * @file Codemode execution environment for running TypeScript/JavaScript code with MCP tools.
 *
 * This module provides a secure execution environment that allows running user-provided
 * TypeScript/JavaScript code with access to MCP (Model Context Protocol) tools, algorithms,
 * Playwright automation, and other development utilities. It includes git hook management
 * and environment isolation to prevent interference with the development workflow.
 *
 * @author Generated by Reynard AI Tool-Calling System
 */

import { McpClient } from "./mcp-client";
import { setupCodemodeEnvironment, buildMcpFacade, loadPlaywrightPackages, executeUserCode } from "./execution-utils";

export type CodeModeConfig = {
  projectRoot: string;
  timeoutMs?: number;
};

/**
 * Creates a CodeMode execution environment with access to MCP tools, algorithms, and Playwright modules.
 *
 * @param {CodeModeConfig} config - Configuration object containing project root and optional timeout
 * @returns {Promise<CodeModeSandbox>} Promise that resolves to a CodeMode sandbox with execution capabilities
 * @example
 * ```typescript
 * const cm = await codemode({ projectRoot: "/path/to/project", timeoutMs: 10000 });
 * const result = await cm.executeCode('console.log("Hello from CodeMode!");');
 * ```
 */
export async function codemode(config: CodeModeConfig) {
  setupCodemodeEnvironment();

  const client = new McpClient(config.projectRoot);
  await client.initialize();

  const mcp = await buildMcpFacade(client);
  const algorithms = (await import("reynard-algorithms")) as Record<string, unknown>;
  const playwrightPackages = await loadPlaywrightPackages();
  const devToolsPackages: Record<string, unknown> = {};

  console.log("âœ… Dev-tools packages re-enabled with conditional execution support");

  const context = { mcp, algorithms, playwrightPackages, devToolsPackages };

  return {
    async healthCheck() {
      try {
        const listed = await client.toolsList();
        return { ok: true, count: listed.length };
      } catch (e) {
        return { ok: false, error: (e as Error).message };
      }
    },
    async executeCode(code: string) {
      return executeUserCode(code, context);
    },
    cleanup() {
      client.stop();
    },
  };
}
