/**
 * @file Codemode execution environment for running TypeScript/JavaScript code with MCP tools.
 *
 * This module provides a secure execution environment that allows running user-provided
 * TypeScript/JavaScript code with access to MCP (Model Context Protocol) tools, algorithms,
 * Playwright automation, and other development utilities. It includes git hook management
 * and environment isolation to prevent interference with the development workflow.
 *
 * @author Generated by Reynard AI Tool-Calling System
 */

import { setupCodemodeEnvironment, buildToolsFacade, loadPlaywrightPackages, executeUserCode } from "./execution-utils";

export type CodeModeConfig = {
  projectRoot: string;
  timeoutMs?: number;
};

/**
 * Creates a CodeMode execution environment with access to MCP tools, algorithms, and Playwright modules.
 *
 * @param {CodeModeConfig} config - Configuration object containing project root and optional timeout
 * @returns {Promise<CodeModeSandbox>} Promise that resolves to a CodeMode sandbox with execution capabilities
 * @example
 * ```typescript
 * const cm = await codemode({ projectRoot: "/path/to/project", timeoutMs: 10000 });
 * const result = await cm.executeCode('console.log("Hello from CodeMode!");');
 * ```
 */
export async function codemode(config: CodeModeConfig) {
  setupCodemodeEnvironment();

  // Use native tools instead of MCP client
  const tools = await buildToolsFacade();
  const algorithms = (await import("reynard-algorithms")) as Record<string, unknown>;
  const playwrightPackages = await loadPlaywrightPackages();
  const devToolsPackages: Record<string, unknown> = {};

  console.log("âœ… Native tools system initialized with conditional execution support");

  const context = { tools, algorithms, playwrightPackages, devToolsPackages };

  return {
    async healthCheck() {
      try {
        const { getAllTools } = await import("../tools");
        const tools = getAllTools();
        return { ok: true, count: tools.length };
      } catch (e) {
        return { ok: false, error: (e as Error).message };
      }
    },
    async executeCode(code: string) {
      return executeUserCode(code, context);
    },
    // No cleanup needed for native tools
  };
}
